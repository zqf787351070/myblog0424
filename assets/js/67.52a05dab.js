(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{1004:function(s,a,t){"use strict";t.r(a);var e=t(6),_=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"_1-mybatis-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-mybatis-是什么"}},[s._v("#")]),s._v(" 1. MyBatis 是什么？")]),s._v(" "),t("p",[s._v("答：")]),s._v(" "),t("p",[s._v("MyBatis 是一个"),t("strong",[s._v("半ORM（对象关系映射）框架")]),s._v("，其内部封装了 JDBC，开发是只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等复杂的过程。")]),s._v(" "),t("p",[s._v("通过直接编写原生态 SQL，可以严格控制 SQL 语句的执行性能，"),t("strong",[s._v("支持动态 SQL")]),s._v("，灵活度高。")]),s._v(" "),t("p",[s._v("MyBatis "),t("strong",[s._v("使用 XML 或注解来配置和映射原生信息")]),s._v("，将实体类映射成数据库中的记录，避免了 JDBC 代码手动设置参数以及获取结果集的繁琐步骤。")]),s._v(" "),t("p",[s._v("MyBatis "),t("strong",[s._v("通过 XML 或注解将要执行的各种 statement 进行配置")]),s._v("，通过 Java 对象和 statement 中的动态参数进行映射并最终形成执行的 SQL 语句。最后由 MyBatis 框架执行 SQL 语句，并将结果映射为 Java 对象返回。")]),s._v(" "),t("h1",{attrs:{id:"_2-mybatis-的核心组件有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-mybatis-的核心组件有哪些"}},[s._v("#")]),s._v(" 2. MyBatis 的核心组件有哪些？")]),s._v(" "),t("p",[s._v("答：MyBatis 核心组件包括 "),t("strong",[s._v("SqlSessionFactoryBuilder / SqlSessionFactory / SqlSession / Mapper")]),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"sqlsessionfactorybuilder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sqlsessionfactorybuilder"}},[s._v("#")]),s._v(" SqlSessionFactoryBuilder")]),s._v(" "),t("p",[s._v("SqlSessionFactoryBuilder 是一个构建器，用于构建 SqlSessionFactory。其生命周期一般只存在于方法的局部，用完即可收回。")]),s._v(" "),t("p",[s._v("构建语句：\n"),t("code",[s._v("SqlSessionFactory factory = SqlSessionFactoryBuilder.build(inputStream);")])]),s._v(" "),t("h2",{attrs:{id:"sqlsessionfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sqlsessionfactory"}},[s._v("#")]),s._v(" SqlSessionFactory")]),s._v(" "),t("p",[s._v("SqlSessionFactory 用于创建 SqlSession，即创建一个对话。")]),s._v(" "),t("p",[s._v("每次程序访问数据库，都需要使用 SqlSession，所以 SqlSessionFactory 应该存在于 MyBatis 应用的整个生命周期中。")]),s._v(" "),t("p",[s._v("为了减少创建会话带来的资源消耗，一般使用单例模式创建 SqlSession。")]),s._v(" "),t("p",[s._v("创建语句：\n"),t("code",[s._v("SqlSession sqlSession = SqlSessionFactory.openSession();")])]),s._v(" "),t("h2",{attrs:{id:"sqlsession"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sqlsession"}},[s._v("#")]),s._v(" SqlSession")]),s._v(" "),t("p",[s._v("SqlSession 就是一个对话，既可以发送 SQL 语句去执行返回结果，也可以代理 Mapper 接口。")]),s._v(" "),t("p",[s._v("SqlSession 是一个线程不安全的对象，其生命周期应该在请求数据库处理事务的过程中。")]),s._v(" "),t("p",[s._v("每次创建的 SqlSession 对象应该及时关闭，否则会使得数据库连接池的活动资源变少，影响系统性能。")]),s._v(" "),t("h2",{attrs:{id:"mapper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mapper"}},[s._v("#")]),s._v(" Mapper")]),s._v(" "),t("p",[s._v("Mapper 用于 MyBatis 代理 DAO，通过注解和 XML 文件可以获取对应的 SQL 和映射规则。")]),s._v(" "),t("p",[s._v("使用语句：\n"),t("code",[s._v("XXMapper xxMapper = sqlSession.getMapper(XXMapper.class);")])]),s._v(" "),t("h1",{attrs:{id:"_3-mybatis-的动态-sql-有了解么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-mybatis-的动态-sql-有了解么"}},[s._v("#")]),s._v(" 3. MyBatis 的动态 SQL 有了解么？")]),s._v(" "),t("p",[s._v("答：MyBatis 可以在 xml 映射文件中以标签的形式实现动态 SQL，其原理是"),t("strong",[s._v("根据表达式的值完成逻辑判断并动态拼接 SQL 语句")]),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"动态-sql-标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态-sql-标签"}},[s._v("#")]),s._v(" 动态 SQL 标签")]),s._v(" "),t("ul",[t("li",[s._v("if：单条件分支的判断语句")]),s._v(" "),t("li",[s._v("choose, when, otherwise：多条件的分支判断语句")]),s._v(" "),t("li",[s._v("foreach：列举条件，遍历集合，实现循环语句")]),s._v(" "),t("li",[s._v("trim,where,set：是一些辅助元素，可以对拼接的SQL进行处理")]),s._v(" "),t("li",[s._v("bind：进行模糊匹配查询的时候使用，提高数据库的可移植性")])]),s._v(" "),t("h1",{attrs:{id:"_4-mybatis-的-mapper-中常用标签有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-mybatis-的-mapper-中常用标签有哪些"}},[s._v("#")]),s._v(" 4. Mybatis 的 Mapper 中常用标签有哪些？")]),s._v(" "),t("p",[s._v("答：")]),s._v(" "),t("ul",[t("li",[s._v("| select | insert | update | delete |")]),s._v(" "),t("li",[s._v("| resultMap | resultType |")]),s._v(" "),t("li",[s._v("| where | if | foreach | sql |")])]),s._v(" "),t("h1",{attrs:{id:"_5-mybatis-的-dao-接口的工作原理有了解么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-mybatis-的-dao-接口的工作原理有了解么"}},[s._v("#")]),s._v(" 5. MyBatis 的 DAO 接口的工作原理有了解么？")]),s._v(" "),t("p",[s._v("答：")]),s._v(" "),t("p",[t("strong",[s._v("DAO 接口即 Mapper 接口")]),s._v("。接口的全限名就是映射文件中 namespace 的值；接口的方法名，就是映射文件中的 id 值；接口方法内的参数，就是传递给 SQL 的参数。")]),s._v(" "),t("p",[s._v("Mapper 接口没有实现类，调用接口方法的时候，使用接口"),t("strong",[s._v("全限名 + 方法名")]),s._v("拼接字符串作为 key 值，可"),t("strong",[s._v("唯一定位一个 MapperStatement")]),s._v("。在 MyBatis 中，每一个"),t("code",[s._v("<select>、<insert>、<update>、<delete>")]),s._v("标签，都会被解析为一个 "),t("strong",[s._v("MapperStatement对象")]),s._v("。")]),s._v(" "),t("p",[t("strong",[s._v("Mapper 接口的工作原理是 JDK 动态代理")]),s._v("，MyBatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 SQL，然后将 SQL 执行结果返回。")]),s._v(" "),t("h2",{attrs:{id:"dao-接口中的方法可以重载么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dao-接口中的方法可以重载么"}},[s._v("#")]),s._v(" DAO 接口中的方法可以重载么？")]),s._v(" "),t("p",[s._v("答：不可以。因为 xml 文件中使用的是"),t("strong",[s._v("全限名 + 方法名")]),s._v("的保存和寻找策略。")]),s._v(" "),t("h2",{attrs:{id:"不同映射文件-xml-中的-id-可以重复么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同映射文件-xml-中的-id-可以重复么"}},[s._v("#")]),s._v(" 不同映射文件 xml 中的 id 可以重复么？")]),s._v(" "),t("p",[s._v("答：如果配置了 namesapce，那么 id 可以重复； 如果没有配置，则不可以重复。")]),s._v(" "),t("h1",{attrs:{id:"_6-mybatis-中-和-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-mybatis-中-和-的区别"}},[s._v("#")]),s._v(" 6. MyBatis 中 # 和 $ 的区别")]),s._v(" "),t("p",[s._v("答：能用 # 就尽量不用 $")]),s._v(" "),t("ul",[t("li",[s._v("# 将传入的数据都当做一个"),t("strong",[s._v("字符串")]),s._v("，会对传入的数据加一个双引号；# 存在"),t("strong",[s._v("预编译过程")]),s._v("，对问号进行赋值，防止 SQL 注入。")]),s._v(" "),t("li",[s._v("$ 将传入的数据"),t("strong",[s._v("直接显示")]),s._v("在生成的 SQL 语句；$ 采用的是直译的方式。")])]),s._v(" "),t("h1",{attrs:{id:"_7-mybatis-的缓存机制有了解么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-mybatis-的缓存机制有了解么"}},[s._v("#")]),s._v(" 7. MyBatis 的缓存机制有了解么？")]),s._v(" "),t("p",[s._v("答：分为一级缓存和二级缓存。")]),s._v(" "),t("ul",[t("li",[t("p",[t("strong",[s._v("一级缓存（同一个SqlSession）")]),s._v("\n基于 HashMap的本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有缓存就将清空，默认打开一级缓存。")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("二级缓存（同一个SqlSessionFactory）")]),s._v("\n二级缓存与一级缓存其机制相同，默认也是采用 HashMap的本地存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源。")])])]),s._v(" "),t("h1",{attrs:{id:"_8-mybatis-的接口绑定是什么-有哪些方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-mybatis-的接口绑定是什么-有哪些方式"}},[s._v("#")]),s._v(" 8. MyBatis 的接口绑定是什么？有哪些方式？")]),s._v(" "),t("p",[s._v("答：接口绑定即 MyBatis 代理 DAO 接口，将接口里的方法和 xml 映射文件中 SQL 语句绑定。我们在使用的时候直接调用接口方法即可。")]),s._v(" "),t("ul",[t("li",[s._v("注解绑定："),t("code",[s._v("@Select、@Update")])]),s._v(" "),t("li",[s._v("xml 绑定：设置 namespace 为全路径名")])])])}),[],!1,null,null,null);a.default=_.exports}}]);